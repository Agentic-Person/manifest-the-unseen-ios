<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouTube → Knowledge Base</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 700px;
      margin: 40px auto;
      padding: 30px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }

    h1 {
      font-size: 28px;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #9333ea 0%, #c084fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: #a0a0a0;
      margin-bottom: 24px;
      font-size: 14px;
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }

    .tab {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #888;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .tab.active {
      background: rgba(147, 51, 234, 0.2);
      border-color: rgba(147, 51, 234, 0.5);
      color: #c084fc;
    }

    .tab:hover:not(.active) {
      background: rgba(255, 255, 255, 0.08);
      color: #aaa;
    }

    .input-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #c0c0c0;
      font-size: 14px;
    }

    input[type="text"] {
      width: 100%;
      padding: 14px 16px;
      font-size: 16px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      color: #fff;
      outline: none;
      transition: all 0.2s ease;
    }

    textarea {
      width: 100%;
      padding: 14px 16px;
      font-size: 14px;
      font-family: monospace;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      color: #fff;
      outline: none;
      transition: all 0.2s ease;
      resize: vertical;
      min-height: 150px;
    }

    input[type="text"]:focus, textarea:focus {
      border-color: #9333ea;
      background: rgba(147, 51, 234, 0.1);
    }

    input[type="text"]::placeholder, textarea::placeholder {
      color: #666;
    }

    button {
      width: 100%;
      padding: 14px 24px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(147, 51, 234, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .queue-status {
      margin-top: 20px;
      padding: 16px;
      background: rgba(30, 64, 175, 0.2);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 10px;
      display: none;
    }

    .queue-status.show {
      display: block;
    }

    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .queue-title {
      font-weight: 600;
      color: #93c5fd;
    }

    .queue-progress {
      font-size: 13px;
      color: #60a5fa;
    }

    .queue-items {
      max-height: 300px;
      overflow-y: auto;
    }

    .queue-item {
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .queue-item.processing {
      background: rgba(147, 51, 234, 0.15);
      border-left: 3px solid #9333ea;
    }

    .queue-item.success {
      background: rgba(22, 101, 52, 0.2);
      border-left: 3px solid #22c55e;
    }

    .queue-item.error {
      background: rgba(153, 27, 27, 0.2);
      border-left: 3px solid #ef4444;
    }

    .queue-item.pending {
      opacity: 0.6;
    }

    .queue-item-status {
      width: 20px;
      text-align: center;
    }

    .queue-item-title {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .queue-item-chunks {
      color: #888;
      font-size: 12px;
    }

    .spinner-small {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(147, 51, 234, 0.3);
      border-radius: 50%;
      border-top-color: #9333ea;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-top: 20px;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.03);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: #c084fc;
    }

    .stat-label {
      font-size: 11px;
      color: #666;
      text-transform: uppercase;
      margin-top: 4px;
    }

    .history {
      margin-top: 24px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .history h2 {
      font-size: 16px;
      color: #a0a0a0;
      margin-bottom: 12px;
    }

    .history-item {
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      margin-bottom: 8px;
      font-size: 13px;
    }

    .history-item .title {
      color: #c084fc;
      font-weight: 500;
    }

    .history-item .meta {
      color: #666;
      margin-top: 4px;
    }

    .help-text {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }

    .hidden {
      display: none;
    }

    .concurrency-setting {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #888;
    }

    .concurrency-setting select {
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      color: #fff;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>YouTube → Knowledge Base</h1>
    <p class="subtitle">Add YouTube video transcripts to the RAG knowledge base</p>

    <div class="tabs">
      <div class="tab active" onclick="switchTab('single')">Single URL</div>
      <div class="tab" onclick="switchTab('batch')">Batch (Multiple URLs)</div>
    </div>

    <!-- Single URL Mode -->
    <div id="single-mode">
      <div class="input-group">
        <label for="url">YouTube URL</label>
        <input
          type="text"
          id="url"
          placeholder="https://youtube.com/watch?v=... or https://youtu.be/..."
          autocomplete="off"
        />
      </div>
      <button id="processBtn" onclick="processSingle()">
        Process Video
      </button>
    </div>

    <!-- Batch Mode -->
    <div id="batch-mode" class="hidden">
      <div class="input-group">
        <label for="urls">YouTube URLs (one per line)</label>
        <textarea
          id="urls"
          placeholder="https://youtube.com/watch?v=abc123
https://youtube.com/watch?v=def456
https://youtu.be/ghi789"
        ></textarea>
        <p class="help-text">Paste multiple YouTube URLs, one per line. Duplicates will be skipped.</p>
      </div>

      <div class="concurrency-setting">
        <label for="concurrency">Process</label>
        <select id="concurrency">
          <option value="2">2 at a time</option>
          <option value="3" selected>3 at a time</option>
          <option value="5">5 at a time</option>
        </select>
        <span>(higher = faster but may hit rate limits)</span>
      </div>

      <button id="batchBtn" onclick="processBatch()">
        Process All Videos
      </button>
    </div>

    <!-- Queue Status -->
    <div id="queue-status" class="queue-status">
      <div class="queue-header">
        <span class="queue-title">Processing Queue</span>
        <span class="queue-progress" id="queue-progress">0/0</span>
      </div>
      <div class="queue-items" id="queue-items"></div>
    </div>

    <!-- Stats -->
    <div class="stats" id="stats">
      <div class="stat-box">
        <div class="stat-value" id="totalVideos">0</div>
        <div class="stat-label">Videos</div>
      </div>
      <div class="stat-box">
        <div class="stat-value" id="totalChunks">0</div>
        <div class="stat-label">Chunks</div>
      </div>
      <div class="stat-box">
        <div class="stat-value" id="sessionCount">0</div>
        <div class="stat-label">This Session</div>
      </div>
    </div>

    <!-- History -->
    <div class="history" id="historySection" style="display: none;">
      <h2>Completed</h2>
      <div id="history"></div>
    </div>
  </div>

  <script>
    // State
    let sessionCount = 0;
    let queue = [];
    let processing = false;

    // Tab switching
    function switchTab(mode) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.tab[onclick="switchTab('${mode}')"]`).classList.add('active');

      document.getElementById('single-mode').classList.toggle('hidden', mode !== 'single');
      document.getElementById('batch-mode').classList.toggle('hidden', mode !== 'batch');
    }

    // Process single URL
    async function processSingle() {
      const url = document.getElementById('url').value.trim();
      if (!url) return;

      const btn = document.getElementById('processBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner-small"></span> Processing...';

      const result = await processUrl(url);

      if (result.success) {
        addToHistory(result);
        document.getElementById('url').value = '';
        sessionCount++;
        updateStats();
      } else {
        alert('Error: ' + result.error);
      }

      btn.disabled = false;
      btn.innerHTML = 'Process Video';
    }

    // Process batch URLs
    async function processBatch() {
      const urlsText = document.getElementById('urls').value.trim();
      if (!urlsText) return;

      const urls = urlsText
        .split('\n')
        .map(u => u.trim())
        .filter(u => u.length > 0 && (u.includes('youtube.com') || u.includes('youtu.be')));

      if (urls.length === 0) {
        alert('No valid YouTube URLs found');
        return;
      }

      const concurrency = parseInt(document.getElementById('concurrency').value);
      const btn = document.getElementById('batchBtn');
      btn.disabled = true;
      btn.innerHTML = `Processing ${urls.length} videos...`;

      // Initialize queue
      queue = urls.map((url, i) => ({
        id: i,
        url,
        status: 'pending',
        title: extractVideoId(url) || url,
        chunks: 0,
        error: null
      }));

      renderQueue();
      document.getElementById('queue-status').classList.add('show');

      // Process with concurrency
      await processQueueWithConcurrency(concurrency);

      btn.disabled = false;
      btn.innerHTML = 'Process All Videos';
      document.getElementById('urls').value = '';
    }

    // Extract video ID for display
    function extractVideoId(url) {
      const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);
      return match ? match[1] : null;
    }

    // Process queue with concurrency limit
    async function processQueueWithConcurrency(limit) {
      const results = [];
      let index = 0;

      async function worker() {
        while (index < queue.length) {
          const i = index++;
          const item = queue[i];

          item.status = 'processing';
          renderQueue();

          const result = await processUrl(item.url);

          if (result.success) {
            item.status = 'success';
            item.title = result.title;
            item.chunks = result.chunks;
            sessionCount++;
            addToHistory(result);
          } else {
            item.status = 'error';
            item.error = result.error;
          }

          renderQueue();
          updateStats();
        }
      }

      // Start workers
      const workers = [];
      for (let i = 0; i < Math.min(limit, queue.length); i++) {
        workers.push(worker());
      }

      await Promise.all(workers);
    }

    // Render queue status
    function renderQueue() {
      const container = document.getElementById('queue-items');
      const completed = queue.filter(q => q.status === 'success' || q.status === 'error').length;

      document.getElementById('queue-progress').textContent = `${completed}/${queue.length}`;

      container.innerHTML = queue.map(item => `
        <div class="queue-item ${item.status}">
          <span class="queue-item-status">
            ${item.status === 'pending' ? '⏳' : ''}
            ${item.status === 'processing' ? '<span class="spinner-small"></span>' : ''}
            ${item.status === 'success' ? '✅' : ''}
            ${item.status === 'error' ? '❌' : ''}
          </span>
          <span class="queue-item-title">${item.title}</span>
          ${item.chunks > 0 ? `<span class="queue-item-chunks">${item.chunks} chunks</span>` : ''}
          ${item.error ? `<span class="queue-item-chunks" style="color: #f87171;">${item.error.substring(0, 30)}...</span>` : ''}
        </div>
      `).join('');
    }

    // Process a single URL
    async function processUrl(url) {
      try {
        const response = await fetch('http://localhost:3456/process', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        return await response.json();
      } catch (err) {
        return { success: false, error: err.message };
      }
    }

    // Update stats display
    async function updateStats() {
      document.getElementById('sessionCount').textContent = sessionCount;

      try {
        const response = await fetch('http://localhost:3456/stats');
        const stats = await response.json();
        document.getElementById('totalChunks').textContent = stats.totalChunks || 0;
        document.getElementById('totalVideos').textContent = stats.totalVideos || 0;
      } catch (err) {
        // Ignore
      }
    }

    // Add to history
    function addToHistory(result) {
      const historySection = document.getElementById('historySection');
      const historyContainer = document.getElementById('history');

      historySection.style.display = 'block';

      const item = document.createElement('div');
      item.className = 'history-item';
      item.innerHTML = `
        <div class="title">${result.title}</div>
        <div class="meta">${result.channel} • ${result.chunks} chunks • ${result.duration}s</div>
      `;

      historyContainer.insertBefore(item, historyContainer.firstChild);
    }

    // Allow Enter key to submit in single mode
    document.getElementById('url').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') processSingle();
    });

    // Load initial stats
    updateStats();

    // Focus input on load
    document.getElementById('url').focus();
  </script>
</body>
</html>
